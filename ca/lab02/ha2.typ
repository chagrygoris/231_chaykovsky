#include "typst-sympy-calculator.typ"


#set text(
    font: "New Computer Modern"
)
= Home assignment 2

== Task 1

=== Unsigned

$0 = sum_(i = 0)^(5) 0 * 2^i arrow.r.double 0_(10) = 000000_2$

$13 = 2^0 + 2^3 + 2^2 arrow.r.double 001101$

$24 = 2^4 + 2^3 arrow.r.double 011000$

$sum_(i = 0)^(n-1) 2^i = 2^n arrow.r.double 1 + 2 + ... +   32 = 63 arrow.r.double 63_(10) = 111111_(2)$

=== Signed

$16 = 010000$ (sign-bit set to zero since 16 is positive, fourth bit set to 1 since $16=2^4$)

$-2 = 111110$ (+2 is 000010, 1st complement is 111101)

$31 = 0111111$ (1 + 2 + ... + 16)

$-32 = 100000$ (+32 = 100000, 1st complement is 011111)

== Task 2

=== Unsingned

$000101 = 2^0 + 2^2 = 5$

$101011 = 2^0 + 2^1 + 2^3 + 2^5$ = 43

$111111 = 63$

$100000 = 32 = 2^5$

=== Signed


$000101$ - positive integer $arrow.r.double$ 5

$101011$ - negative integer; $101011 - 1 = 101010, 1overline(01010) = 110101 = -21$

$111111$ - negative integer. $11111 - 1 = 11110, overline(11110)$ = 00001 $arrow.r.double 111111 = -1$

$100000$ - negative integer. $00000 - 1 = 00000, overline(00000) = 11111 = 32 arrow.r.double 100000 = -32$


== Task 3

$7 = 7 * 16^0 = 0x 00000007$

$240 = 16^1 * 15 + 16^0 * 0 = 0x 000000 F 0$

$171 = 16^1 * 10 + 16^0 * 11 = 0x 000000 A B$

$126 = 16^1 * 7 + 16^0 * 14 = 0x 000007 E$

== Task 4

$"0x3C" = 12 + 3 * 16 = 60 = 32 + 16 + 8 + 4 = 00111100$

$"0x7E" = 14 + 7 * 16 =  126 = 128-2 = 10000000 - 1 - 1 = 01111111 - 1 = 01111110$

$"0xFF" = 15 + 16 * 15 = 255 = 11111111$

$"0xA5" = 5 + 16*10 = 165 = 128 + 37 = 128 + 32 + 4 + 1 = 10100101$

== Task 5

Для хранения чисел от -256 до 255 нужно 9 бит. 

В каждом случае нужно выполнить следующую операцию: инвертировать все биты, прибавить единицу, приписать 1 слева (бит, отвечающий за отрицательный знак)

$00111100 -> 11000011 + 1 -> 11000100 -> 111000100$

$01111110 -> 10000001 + 1 -> 10000010 -> 110000010$

$11111111 -> 00000000 + 1 ->00000001 -> 100000001$

$10100101 -> 01011010 + 1 -> 01011011 -> 101011011$


== Task 6

В случае архитектуры big-endian:

Байт 1: "0xDE"

Байт 2: "0xAD"

Байт 3: "0xBE"

Байт 4: "0xEF"

В случае little-endian:

Байт 4: "0xDE"

Байт 3: "0xAD"

Байт 2: "0xBE"

Байт 1: "0xEF"


== Task 7

=== Sign-extension

7 = 00111 -> 000|00111

15 = 01111 -> 000|01111

-16 = 10000 -> 111|10000 (инвертируем все биты в 10000, получаем 01111, добавляем 1 получаем 10000)

-5 = 11011 -> 111|11011 (инвертируем все биты в 00101, получаем 11010, прибавляем 1, получем 11011)

=== Zero-extension

7 = 00111 -> 000|00111

15 = 01111 -> 000|01111

-16 = 10000 -> 000|10000

-5 = 11011 -> 000|11011 

== Task 8

== 1
7 = 0111

9 = 1001

7 + 9 = 0000 (случилось переполнение, результат равен 16, а 4-битный беззнаковый тип может хранить значения от 0 до 15). Если же ограничения на количество бит нету, то результат равен $10000$

== 2

4 = 0100

$5 = 0101 arrow.r.double -5 = 1010 + 1 = 1011$

0100 + 1011 = 1111

1111 = -1 (все верно!)
